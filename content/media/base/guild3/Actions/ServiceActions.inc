// HOW TO ADD SERVICES:
// 1. Define a need that will be satisfied by the service (if it does not exist yet)
// 1.1 In GameplayDefault.oc, in the 'ServiceNeedWeightsMap', create an entry for each social caste that defines how much of a need the NPCs will have.
// 2. Create one action for workers e.g. HealService, HaircutService, BodyCareService
// 2.1 The action must have ServiceNeeds defined e.g. ServiceNeeds = map { "HealNeed" = 0.0; "RelaxNeed" = 0.0 }; NOTE: values are not important
// 3. Create one action for customers e.g. GetHealService, GetHaircutService, GetBathService
// 3.1 The action must have ActionClassName = "GetServiceAction";
// 3.2 The action must have ServiceNeeds defined e.g. ServiceNeeds = map { "HealNeed" = 1.0; "RelaxNeed" = 3.0 }; NOTE: values should reflect the FunctionAffectServiceNeeds inside the action
// 3.3 The action must have at least a FunctionAffectServiceNeeds inside as a result because it's used to affect the service needs of the neighborhood of the customer
// 3.4 The action must have MainTemplateName linking to the waiting action e.g MainTemplateName = "WaitForHealService";
// 3.5 Make sure you add CanProvideService = 3; to TargetProfileBuilding. This is necessary to find a building that offers a service with the same needs that the customer requires (i.e. it matches ServiceNeeds)
// 4. Create one action for waiting customers on a service e.g. WaitForHealService, WaitForDiseaseService, WaitForPoisonService
// 4.1 this action only needs name, description and a new icon when necessary
// 5. Create ResultObjects that will be applied to customers while they wait for / receive the service (in ResultObjectsDefault.oc)
// 5.1 Create a ResultObject StartWaitingX (where 'X' is the name of the GetServiceAction, e.g. "GetHealService" -> the ResultObject should be named "StartWaitingGetHealService")
//     (There is no custom 'StartWaitingX' ResultObject. Instead, a shared ResultObject 'StopWaitingForService' will be used)
//     (This result object may be empty (apply no effects), but should still exist. If it does not exist, it will trigger an assert)
// 5.2 Create a ResultObject StartX (where 'X' is the name of the ServiceAction, e.g. "HealService" -> the ResultObject should be named "StartHealService")
//     (There is no custom 'StopX' ResultObjects. When the service stops, it will use the shared ResultObject 'StopServiceAction')  
//     (This result object may be empty (apply no effects), but should still exist. If it does not exist, it will trigger an assert)
// 6. Create icons and texts for the new actions
// 
// HOW TO ASSIGN SERVICES TO BUILDINGS
// 1. Create the service actions (for providing/receiving/waiting for the service)
// 2. Assign the service to a building via the 'RequiredBuildings' setting in the action template of the 'provide service' action
// 3. Change the building template to indicate that it enables services
// 3.1 Open BuildingTemplatesDefault.oc
// 3.2 For the target building, set EnableServiceProvider = true;
// 4. Unlock the service action where appropriate (e.g. in the corresponding skill tree)

"HealService" = G3ActionTemplate
{
	ActionName = "HealService";
	ActionClassName = "ServiceAction";
	ServiceType = "HealService";
	GUIPresent = false;
	GUIData = array
	{
		ActionGUIData
		{
			IsCharacter = 1;
			BelongsToOwnFamily = 1;
			IsAdult = 1;
		},
		@base/AdultNeutralNPCs
	};

	DisplayName = "$action.TendToDamagedCustomers";
	Description = "$action.TendToDamagedCustomersDesc";
	
	CanFail = false;
	InterruptForSleep = false;
	ShowCombatText = false;
	
	OnlyExecute = true;
	EnterBuilding = "TryEnter";
	
	// List of needs this service can provide. Used as reference when looking for services.
	// The amount is not taken into consideration because it's the GetServiceAction that takes care of it.
	ServiceNeeds = map
	{
		// HealService is special because it does not have a corresponding service need. Instead the need for NPCs and AI for this service is generated by being wounded. Therefore this service is not associated with a service need.
	};
	
	Cooldown = 0.0;
	Duration = 0.0312498; // ~3/4 hour
	
	BudgetPost = "Services";
	
	ActionActor = "Character";
	TargetActor = "AutomationParameters";
	
	SourceScoreFormula = "MedicineMastery";
	
	RequiredBuildings = array
	{
		RequiredBuilding = array { "Shaman", 1 },
		RequiredBuilding = array { "Medicus", 1 }
	};
	
	MoralAlignmentShift = 0.05;
	MoralAlignment = MoralAlignment
	{
		Values = array{0.8,1,0.5};
	};
	
	BaseRewardXP = 33;
};

"GetHealService" = G3ActionTemplate
{
	GUIPresent = true;
	UICategory = "Urgent";
	OrderIndex = 30;

	ActionName = "GetHealService";
	ActionClassName = "GetServiceAction";
	ServiceType = "HealService";

	// Used to specify the action that is shown while the character is waiting in line
	MainTemplateName = "WaitForHealService";
	
	GUIData = array
	{
		ActionGUIData
		{
			IsCharacter = 1;
			BelongsToOwnFamily = 1;
		},
		@base/AllNeutralNPCs
	};
	UsableBy = array{ "$loca.key.anyone" };

	DisplayName = "$action.GetHealingService";
	Description = "$action.GetHealingServiceDesc";
	Instruction = "$callToAction.PickHerbHutOrMedicusInjuries";
	
	CanFail = false;
	InterruptForSleep = false;
	ShowCombatText = true;
	OnlyExecute = false;
	EnterBuilding = "TryEnter";
	
	Cooldown = 0.0;
	Duration = 0.5;
	BudgetPost = "Services";
	PriceFormula = "0.37 * (Health.max - Health) + (Source.hasTag.eventdebuffBleedingWound * 50)";

	// List of needs this action will fulfill. Only used as a reference.
	// FunctionAffectServiceNeeds is still necessary to apply the results
	ServiceNeeds = map
	{
		// HealService is special because it does not have a corresponding service need. Instead the need for NPCs and AI for this service is generated by being wounded. Therefore this service is not associated with a service need.
	};
	
	ActionActor = "Character";
	TargetActor = "Building";
	ShowSelectionPrompt = "UseTargetProfile";
	SelectionPromptCallToAction = "$callToAction.PickHerbHutOrMedicusInjuries";
	SelectionPromptNoTargetMessage = "$selectionPrompt.NoHerbHutOrMedicusInjuries";
	
	DesiredProfiles = array
	{
		TargetProfileBuilding
		{
			CityBuilding = -3;
			CanProvideService = 3; // building that offers a matching service
			// Note: the profile intentionally does not check if the workers are off duty. This way the customers will still queue up for the service at night. While they are waiting in the queue, they receive a buff that prevents them from dying.
			CloseToActor = 2;
			CustomerSatisfaction = 2;
			AlreadyServingCustomers = 2;
			FreeWaitingRoomSpace = 3;
			Burning = -3;
			DoesNotHaveAnyTags = array{"ForceClosed"};
			FamilyProfile = TargetProfileFamily
			{
				MyFamily = 2;
				GoodRelationWithMe = 2;
				Alliance = 2;
				Feud = -2;
			};
		};
	};
	
	CriticalFactor = 1.0;
	
	SuccessResult = array
	{
		FunctionTriggerAction
		{
			Filter = "Target.hasTag.HerbHut";
			ApplyTo = "Source";
			Actions = array{"GetHealServiceNoHerbBandage"};
		},
		FunctionTriggerAction
		{
			Filter = "Target.hasTag.Medicus";
			ApplyTo = "Source";
			Actions = array{"GetHealServiceNoBandage"};
		},
		FunctionTriggerAction
		{
			Filter = "Target.hasTag.HerbHut && Target.hasItems.HerbBandage.1";
			ApplyTo = "Source";
			ActionTarget = "Target";
			Actions = array{"GetHealServiceHerbBandage"};
		},
		FunctionTriggerAction
		{
			Filter = "Target.hasTag.Medicus && Target.hasItems.Bandage.1";
			ApplyTo = "Source";
			ActionTarget = "Target";
			Actions = array{"GetHealServiceBandage"};
		}
	};
	FailureResult = array
	{
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		},
		FunctionUpdateRelationship
		{
			AffectSource = "-1";
		}
	};
};

"GetHealServiceNoHerbBandage" = G3ActionTemplate
{
	GUIPresent = false;

	ActionActor = "Character";
	TargetActor = "Building";
	Cooldown = 0.0;
	
	BudgetPost = "Services";
	
	ActionClassName = "SimpleExecutionAction";
	ActionName = "GetHealServiceNoHerbBandage";
	DisplayName = "$TheBillPlease";
	Description = "$TheBillPleaseDesc";

	SourceScoreFormula = "1";
	TargetScoreFormula = "0";
	
	BaseRewardXP = 0;
	
	CanFail = false;
	CriticalFactor = 1.0;

	ShowCombatText = true;
	OnlyExecute = true;

	SuccessResult = array
	{
		ModifierEffect
		{
			ApplyTo = "Source";
			ActorValue = "Health";
			Mod = "100";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
};

"GetHealServiceHerbBandage" = G3ActionTemplate
{
	GUIPresent = false;

	ActionActor = "Character";
	TargetActor = "Building";
	Cooldown = 0.0;
	
	BudgetPost = "Services";
	
	ActionClassName = "SimpleExecutionAction";
	ActionName = "GetHealServiceHerbBandage";
	DisplayName = "$TheBillPlease";
	Description = "$TheBillPleaseDesc";

	SourceScoreFormula = "1";
	TargetScoreFormula = "0";
	
	BaseRewardXP = 0;
	
	CanFail = false;
	CriticalFactor = 0.85;

	ShowCombatText = true;
	OnlyExecute = true;

	CriticalSuccessResult = array
	{
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.HerbBandage.1";
			Giver = "";
			Receiver = "Target";
			Amount = "210";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.HerbBandage.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"HerbBandage"};
		},
		ModifierEffect
		{
			ApplyTo = "Source";
			ActorValue = "Health";
			Mod = "300";
		},
		FunctionUpdateRelationship
		{
			AffectSource = "3";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
	SuccessResult = array
	{
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.HerbBandage.1";
			Giver = "";
			Receiver = "Target";
			Amount = "165";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.HerbBandage.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"HerbBandage"};
		},
		ModifierEffect
		{
			ApplyTo = "Source";
			ActorValue = "Health";
			Mod = "200";
		},
		FunctionUpdateRelationship
		{
			AffectSource = "2";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
};

"GetHealServiceNoBandage" = G3ActionTemplate
{
	GUIPresent = false;

	ActionActor = "Character";
	TargetActor = "Building";
	Cooldown = 0.0;
	
	BudgetPost = "Services";
	
	ActionClassName = "SimpleExecutionAction";
	ActionName = "GetHealServiceNoBandage";
	DisplayName = "$TheBillPlease";
	Description = "$TheBillPleaseDesc";

	SourceScoreFormula = "1";
	TargetScoreFormula = "0";
	
	BaseRewardXP = 0;
	
	CanFail = false;
	CriticalFactor = 1.0;

	ShowCombatText = true;
	OnlyExecute = true;

	SuccessResult = array
	{
		ModifierEffect
		{
			ApplyTo = "Source";
			ActorValue = "Health";
			Mod = "100";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
};

"GetHealServiceBandage" = G3ActionTemplate
{
	GUIPresent = false;

	ActionActor = "Character";
	TargetActor = "Building";
	Cooldown = 0.0;
	
	BudgetPost = "Services";
	
	ActionClassName = "SimpleExecutionAction";
	ActionName = "GetHealServiceBandage";
	DisplayName = "$TheBillPlease";
	Description = "$TheBillPleaseDesc";

	SourceScoreFormula = "1";
	TargetScoreFormula = "0";
	
	BaseRewardXP = 0;
	
	CanFail = false;
	CriticalFactor = 0.85;

	ShowCombatText = true;
	OnlyExecute = true;

	CriticalSuccessResult = array
	{
		FunctionRemoveEffect
		{
			Filter = "Target.hasItems.Bandage.1 && Source.hasTag.eventdebuffBleedingWound";
			MatchAny = true;
			Tags = array{"eventdebuffBleedingWound"};
			ApplyTo = "Source";
		},
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.Bandage.1 && Source.hasTag.eventdebuffBleedingWound";
			Giver = "";
			Receiver = "Target";
			Amount = "330";
		},
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.Bandage.1 && Source.hasNotTag.eventdebuffBleedingWound";
			Giver = "";
			Receiver = "Target";
			Amount = "210";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.Bandage.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"Bandage"};
		},
		ModifierEffect
		{
			ApplyTo = "Source";
			ActorValue = "Health";
			Mod = "300";
		},
		FunctionUpdateRelationship
		{
			AffectSource = "3";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
	SuccessResult = array
	{
		FunctionRemoveEffect
		{
			Filter = "Target.hasItems.Bandage.1 && Source.hasTag.eventdebuffBleedingWound";
			MatchAny = true;
			Tags = array{"eventdebuffBleedingWound"};
			ApplyTo = "Source";
		},
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.Bandage.1 && Source.hasTag.eventdebuffBleedingWound";
			Giver = "";
			Receiver = "Target";
			Amount = "250";
		},
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.Bandage.1 && Source.hasNotTag.eventdebuffBleedingWound";
			Giver = "";
			Receiver = "Target";
			Amount = "165";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.Bandage.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"Bandage"};
		},
		ModifierEffect
		{
			ApplyTo = "Source";
			ActorValue = "Health";
			Mod = "200";
		},
		FunctionUpdateRelationship
		{
			AffectSource = "2";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
};

"WaitForHealService" = G3ActionTemplate
{
	GUIPresent = false;
	InterruptForSleep = false;
	
	ActionClassName = "G3Action";
	ActionName = "WaitForHealService";
	ServiceType = "HealService";
	DisplayName = "$action.WaitForHealService.name";
	Description = "$action.WaitForHealService.description";
};

"DiseaseService" = G3ActionTemplate
{
	ActionName = "DiseaseService";
	ActionClassName = "ServiceAction";
	ServiceType = "DiseaseService";
	GUIPresent = false;
	GUIData = array
	{
		ActionGUIData
		{
			IsCharacter = 1;
			BelongsToOwnFamily = 1;
			IsAdult = 1;
		},
		@base/AdultNeutralNPCs
	};

	DisplayName = "$action.TendToSickCustomers";
	Description = "$action.TendToSickCustomersDesc";
	
	CanFail = false;
	InterruptForSleep = false;
	ShowCombatText = false;
	
	OnlyExecute = true;
	EnterBuilding = "TryEnter";
	
	// List of needs this service can provide. Used as reference when looking for services.
	// The amount is not taken into consideration because it's the GetServiceAction that takes care of it.
	ServiceNeeds = map
	{
		// DiseaseService is special because it does not have a corresponding service need. Instead the need for NPCs and AI for this service is generated by having an illness. Therefore this service is not associated with a service need.
	};
	
	Cooldown = 0.0;
	Duration = 0.0312498; // ~3/4 hour
	
	BudgetPost = "Services";
	
	ActionActor = "Character";
	TargetActor = "AutomationParameters";
	
	SourceScoreFormula = "MedicineMastery";
	
	RequiredBuildings = array
	{
		RequiredBuilding = array { "Shaman", 1 },
		RequiredBuilding = array { "Medicus", 1 }
	};
	
	MoralAlignmentShift = 0.06;
	MoralAlignment = MoralAlignment
	{
		Values = array{0.8,1,0.5};
	};
	
	BaseRewardXP = 33;
};

"GetDiseaseService" = G3ActionTemplate
{
	GUIPresent = true;
	UICategory = "Urgent";
	OrderIndex = 32;

	ActionName = "GetDiseaseService";
	ActionClassName = "GetServiceAction";
	ServiceType = "DiseaseService";

	// Used to specify the action that is shown while the character is waiting in line
	MainTemplateName = "WaitForDiseaseService";
	
	GUIData = array
	{
		ActionGUIData
		{
			IsCharacter = 1;
			BelongsToOwnFamily = 1;
		},
		@base/AllNeutralNPCs
	};
	UsableBy = array{ "$loca.key.anyone" };

	DisplayName = "$action.GetDiseaseService";
	Description = "$action.GetDiseaseServiceDesc";
	Instruction = "$callToAction.PickHerbHutOrMedicusDisease";
	
	CanFail = false;
	InterruptForSleep = false;
	ShowCombatText = true;
	OnlyExecute = false;
	EnterBuilding = "TryEnter";
	
	Cooldown = 0.0;
	Duration = 0.5;
	BudgetPost = "Services";
	PriceFormula = "25.0 * (hasTag.Cold + hasTag.ScarletFever + hasTag.Measles)";

	// List of needs this action will fulfill. Only used as a reference.
	// FunctionAffectServiceNeeds is still necessary to apply the results
	ServiceNeeds = map
	{
		// DiseaseService is special because it does not have a corresponding service need. Instead the need for NPCs and AI for this service is generated by having an illness. Therefore this service is not associated with a service need.
	};
	
	ActionActor = "Character";
	TargetActor = "Building";
	ShowSelectionPrompt = "UseTargetProfile";
	SelectionPromptCallToAction = "$callToAction.PickHerbHutOrMedicusDisease";
	SelectionPromptNoTargetMessage = "$selectionPrompt.NoHerbHutOrMedicusDisease";
	
	DesiredProfiles = array
	{
		TargetProfileBuilding
		{
			CityBuilding = -3;
			CanProvideService = 3; // building that offers a matching service
			// Note: the profile intentionally does not check if the workers are off duty. This way the customers will still queue up for the service at night. While they are waiting in the queue, they receive a buff that prevents them from dying.
			CloseToActor = 2;
			CustomerSatisfaction = 2;
			AlreadyServingCustomers = 2;
			FreeWaitingRoomSpace = 3;
			Burning = -3;
			DoesNotHaveAnyTags = array{"ForceClosed"};
			FamilyProfile = TargetProfileFamily
			{
				MyFamily = 2;
				GoodRelationWithMe = 2;
				Alliance = 2;
				Feud = -2;
			};
		};
	};
	
	CriticalFactor = 1.0;
	
	SuccessResult = array
	{
		FunctionTriggerAction
		{
			Filter = "Target.hasTag.HerbHut";
			ApplyTo = "Source";
			Actions = array{"GetDiseaseServiceResultNoHerbTea"};
		},
		FunctionTriggerAction
		{
			Filter = "Target.hasTag.Medicus";
			ApplyTo = "Source";
			Actions = array{"GetDiseaseServiceResultNoFeverSyrup"};
		},
		FunctionTriggerAction
		{
			Filter = "Target.hasTag.HerbHut && (Source.hasTag.Cold || Source.hasTag.ScarletFever || Source.hasTag.Measles) && Target.hasItems.HerbTea.1";
			ApplyTo = "Source";
			ActionTarget = "Target";
			Actions = array{"GetDiseaseServiceResultHerbTea"};
		},
		FunctionTriggerAction
		{
			Filter = "Target.hasTag.Medicus && (Source.hasTag.Cold || Source.hasTag.ScarletFever || Source.hasTag.Measles) && Target.hasItems.FeverSyrup.1";
			ApplyTo = "Source";
			ActionTarget = "Target";
			Actions = array{"GetDiseaseServiceResultFeverSyrup"};
		},
	};
	FailureResult = array
	{
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		},
		FunctionUpdateRelationship
		{
			AffectSource = "-1";
		}
	};
};

"GetDiseaseServiceResultNoHerbTea" = G3ActionTemplate
{
	GUIPresent = false;

	ActionActor = "Character";
	TargetActor = "Building";
	Cooldown = 0.0;
	
	BudgetPost = "Services";
	
	ActionClassName = "SimpleExecutionAction";
	ActionName = "GetDiseaseServiceResultNoHerbTea";
	DisplayName = "$TheBillPlease";
	Description = "$TheBillPleaseDesc";

	SourceScoreFormula = "1";
	TargetScoreFormula = "0";
	
	BaseRewardXP = 0;
	
	CanFail = false;
	CriticalFactor = 1.0;

	ShowCombatText = true;
	OnlyExecute = true;

	SuccessResult = array
	{
		FunctionRemoveEffect
		{
			ApplyTo = "Source";
			Tags = array{ "Cold", "ScarletFever", "Measles" };
			MatchAny = true;
		},
		DisplayEffect
		{
			ApplyTo = "Source";
			DisplayGroup = "diseaseimmunity";
			DisplayName = "$DiseaseImmunity.Cured";
			Tags = array{"DiseaseImmunity"};
			Duration = 240;
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
};

"GetDiseaseServiceResultHerbTea" = G3ActionTemplate
{
	GUIPresent = false;

	ActionActor = "Character";
	TargetActor = "Building";
	Cooldown = 0.0;
	
	BudgetPost = "Services";
	
	ActionClassName = "SimpleExecutionAction";
	ActionName = "GetDiseaseServiceResultHerbTea";
	DisplayName = "$TheBillPlease";
	Description = "$TheBillPleaseDesc";

	SourceScoreFormula = "1";
	TargetScoreFormula = "0";
	
	BaseRewardXP = 0;
	
	CanFail = false;
	CriticalFactor = 0.85;

	ShowCombatText = true;
	OnlyExecute = true;

	CriticalSuccessResult = array
	{
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.HerbTea.1";
			Giver = "";
			Receiver = "Target";
			Amount = "150";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.HerbTea.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"HerbTea"};
		},
		FunctionRemoveEffect
		{
			ApplyTo = "Source";
			Tags = array{ "Cold", "ScarletFever", "Measles" };
			MatchAny = true;
		},
		DisplayEffect
		{
			ApplyTo = "Source";
			DisplayGroup = "diseaseimmunity";
			DisplayName = "$DiseaseImmunity.Cured";
			Tags = array{"DiseaseImmunity"};
			Duration = 480;
		},
		FunctionUpdateRelationship
		{
			AffectSource = "3";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
	SuccessResult = array
	{
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.HerbTea.1";
			Giver = "";
			Receiver = "Target";
			Amount = "115";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.HerbTea.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"HerbTea"};
		},
		FunctionRemoveEffect
		{
			ApplyTo = "Source";
			Tags = array{ "Cold", "ScarletFever", "Measles" };
			MatchAny = true;
		},
		DisplayEffect
		{
			ApplyTo = "Source";
			DisplayGroup = "diseaseimmunity";
			DisplayName = "$DiseaseImmunity.Cured";
			Tags = array{"DiseaseImmunity"};
			Duration = 360;
		},
		FunctionUpdateRelationship
		{
			AffectSource = "2";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
};

"GetDiseaseServiceResultNoFeverSyrup" = G3ActionTemplate
{
	GUIPresent = false;

	ActionActor = "Character";
	TargetActor = "Building";
	Cooldown = 0.0;
	
	BudgetPost = "Services";
	
	ActionClassName = "SimpleExecutionAction";
	ActionName = "GetDiseaseServiceResultNoFeverSyrup";
	DisplayName = "$TheBillPlease";
	Description = "$TheBillPleaseDesc";

	SourceScoreFormula = "1";
	TargetScoreFormula = "0";
	
	BaseRewardXP = 0;
	
	CanFail = false;
	CriticalFactor = 1.0;

	ShowCombatText = true;
	OnlyExecute = true;

	SuccessResult = array
	{
		FunctionRemoveEffect
		{
			ApplyTo = "Source";
			Tags = array{ "Cold", "ScarletFever", "Measles" };
			MatchAny = true;
		},
		DisplayEffect
		{
			ApplyTo = "Source";
			DisplayGroup = "diseaseimmunity";
			DisplayName = "$DiseaseImmunity.Cured";
			Tags = array{"DiseaseImmunity"};
			Duration = 240;
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
};

"GetDiseaseServiceResultFeverSyrup" = G3ActionTemplate
{
	GUIPresent = false;

	ActionActor = "Character";
	TargetActor = "Building";
	Cooldown = 0.0;
	
	BudgetPost = "Services";
	
	ActionClassName = "SimpleExecutionAction";
	ActionName = "GetDiseaseServiceResultFeverSyrup";
	DisplayName = "$TheBillPlease";
	Description = "$TheBillPleaseDesc";

	SourceScoreFormula = "1";
	TargetScoreFormula = "0";
	
	BaseRewardXP = 0;
	
	CanFail = false;
	CriticalFactor = 0.85;

	ShowCombatText = true;
	OnlyExecute = true;

	CriticalSuccessResult = array
	{
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.FeverSyrup.1";
			Giver = "";
			Receiver = "Target";
			Amount = "150";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.FeverSyrup.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"FeverSyrup"};
		},
		FunctionRemoveEffect
		{
			ApplyTo = "Source";
			Tags = array{ "Cold", "ScarletFever", "Measles" };
			MatchAny = true;
		},
		DisplayEffect
		{
			ApplyTo = "Source";
			DisplayGroup = "diseaseimmunity";
			DisplayName = "$DiseaseImmunity.Cured";
			Tags = array{"DiseaseImmunity"};
			Duration = 480;
		},
		FunctionUpdateRelationship
		{
			AffectSource = "3";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
	SuccessResult = array
	{
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.FeverSyrup.1";
			Giver = "";
			Receiver = "Target";
			Amount = "115";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.FeverSyrup.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"FeverSyrup"};
		},
		FunctionRemoveEffect
		{
			ApplyTo = "Source";
			Tags = array{ "Cold", "ScarletFever", "Measles" };
			MatchAny = true;
		},
		DisplayEffect
		{
			ApplyTo = "Source";
			DisplayGroup = "diseaseimmunity";
			DisplayName = "$DiseaseImmunity.Cured";
			Tags = array{"DiseaseImmunity"};
			Duration = 360;
		},
		FunctionUpdateRelationship
		{
			AffectSource = "2";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
};

"WaitForDiseaseService" = G3ActionTemplate
{
	GUIPresent = false;
	InterruptForSleep = false;
	ActionClassName = "G3Action";
	ActionName = "WaitForDiseaseService";
	ServiceType = "DiseaseService";
	DisplayName = "$action.WaitForDiseaseService.name";
	Description = "$action.WaitForDiseaseService.description";
};

"GetDiseaseServiceMedicus" = G3ActionTemplate
{
	GUIPresent = true;
	UICategory = "Urgent";
	OrderIndex = 33;

	ActionName = "GetDiseaseServiceMedicus";
	ActionClassName = "GetServiceAction";
	ServiceType = "DiseaseService";

	// Used to specify the action that is shown while the character is waiting in line
	MainTemplateName = "WaitForDiseaseServiceMedicus";
	
	GUIData = array
	{
		ActionGUIData
		{
			IsCharacter = 1;
			BelongsToOwnFamily = 1;
		},
		@base/AllNeutralNPCs
	};
	UsableBy = array{ "$loca.key.anyone" };

	DisplayName = "$action.GetDiseaseServiceMedicus";
	Description = "$action.GetDiseaseServiceMedicusDesc";
	Instruction = "$callToAction.PickMedicusDisease";
	
	CanFail = false;
	InterruptForSleep = false;
	ShowCombatText = true;
	OnlyExecute = false;
	EnterBuilding = "TryEnter";
	
	Cooldown = 0.0;
	Duration = 0.5;
	BudgetPost = "Services";
	PriceFormula = "25.0 * (hasTag.Plague + hasTag.Leprosy)";

	// List of needs this action will fulfill. Only used as a reference.
	// FunctionAffectServiceNeeds is still necessary to apply the results
	ServiceNeeds = map
	{
		// DiseaseService is special because it does not have a corresponding service need. Instead the need for NPCs and AI for this service is generated by having an illness. Therefore this service is not associated with a service need.
	};
	
	ActionActor = "Character";
	TargetActor = "Building";
	ShowSelectionPrompt = "UseTargetProfile";
	SelectionPromptCallToAction = "$callToAction.PickMedicusDisease";
	SelectionPromptNoTargetMessage = "$selectionPrompt.NoMedicusDisease";
	
	DesiredProfiles = array
	{
		TargetProfileBuilding
		{
			CityBuilding = -3;
			CanProvideService = 3; // building that offers a matching service
			// Note: the profile intentionally does not check if the workers are off duty. This way the customers will still queue up for the service at night. While they are waiting in the queue, they receive a buff that prevents them from dying.
			CloseToActor = 2;
			CustomerSatisfaction = 2;
			AlreadyServingCustomers = 2;
			FreeWaitingRoomSpace = 3;
			Burning = -3;
			DoesNotHaveAnyTags = array{"ForceClosed"};
			IncludedTypes = array {"Medicus"};
			FamilyProfile = TargetProfileFamily
			{
				MyFamily = 2;
				GoodRelationWithMe = 2;
				Alliance = 2;
				Feud = -2;
			};
		};
	};
	
	CriticalFactor = 1.0;
	
	SuccessResult = array
	{
		FunctionTriggerAction
		{
			Filter = "Source.hasTag.Leprosy && !Target.hasItems.PainKiller.1";
			ApplyTo = "Source";
			Actions = array{"GetDiseaseServiceResultNoPainKiller"};
		},
		FunctionTriggerAction
		{
			Filter = "Source.hasTag.Plague && !Target.hasItems.WonderCure.1";
			ApplyTo = "Source";
			Actions = array{"GetDiseaseServiceResultNoWonderCure"};
		},
		FunctionTriggerAction
		{
			Filter = "Source.hasTag.Leprosy && Target.hasItems.PainKiller.1";
			ApplyTo = "Source";
			ActionTarget = "Target";
			Actions = array{"GetDiseaseServiceResultPainKiller"};
		},
		FunctionTriggerAction
		{
			Filter = "Source.hasTag.Plague && Target.hasItems.WonderCure.1";
			ApplyTo = "Source";
			ActionTarget = "Target";
			Actions = array{"GetDiseaseServiceResultWonderCure"};
		}
	};
	FailureResult = array
	{
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		},
		FunctionUpdateRelationship
		{
			AffectSource = "-1";
		}
	};
};

"GetDiseaseServiceResultNoWonderCure" = G3ActionTemplate
{
	GUIPresent = false;

	ActionActor = "Character";
	TargetActor = "Building";
	Cooldown = 0.0;
	
	BudgetPost = "Services";
	
	ActionClassName = "SimpleExecutionAction";
	ActionName = "GetDiseaseServiceResultNoWonderCure";
	DisplayName = "$TheBillPlease";
	Description = "$TheBillPleaseDesc";

	SourceScoreFormula = "1";
	TargetScoreFormula = "0";
	
	BaseRewardXP = 0;
	
	CanFail = false;
	CriticalFactor = 1.0;

	ShowCombatText = true;
	OnlyExecute = true;

	SuccessResult = array
	{
		FunctionRemoveEffect
		{
			ApplyTo = "Source";
			Tags = array{ "Plague" };
			MatchAny = true;
		},
		DisplayEffect
		{
			ApplyTo = "Source";
			DisplayGroup = "diseaseimmunity";
			DisplayName = "$DiseaseImmunity.Cured";
			Tags = array{"DiseaseImmunity"};
			Duration = 240;
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
};

"GetDiseaseServiceResultWonderCure" = G3ActionTemplate
{
	GUIPresent = false;

	ActionActor = "Character";
	TargetActor = "Building";
	Cooldown = 0.0;
	
	BudgetPost = "Services";
	
	ActionClassName = "SimpleExecutionAction";
	ActionName = "GetDiseaseServiceResultWonderCure";
	DisplayName = "$TheBillPlease";
	Description = "$TheBillPleaseDesc";

	SourceScoreFormula = "1";
	TargetScoreFormula = "0";
	
	BaseRewardXP = 0;
	
	CanFail = false;
	CriticalFactor = 0.85;

	ShowCombatText = true;
	OnlyExecute = true;

	CriticalSuccessResult = array
	{
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.WonderCure.1";
			Giver = "";
			Receiver = "Target";
			Amount = "930";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.WonderCure.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"WonderCure"};
		},
		FunctionRemoveEffect
		{
			ApplyTo = "Source";
			Tags = array{ "Plague" };
			MatchAny = true;
		},
		DisplayEffect
		{
			ApplyTo = "Source";
			DisplayGroup = "diseaseimmunity";
			DisplayName = "$DiseaseImmunity.Cured";
			Tags = array{"DiseaseImmunity"};
			Duration = 480;
		},
		FunctionUpdateRelationship
		{
			AffectSource = "3";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
	SuccessResult = array
	{
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.WonderCure.1";
			Giver = "";
			Receiver = "Target";
			Amount = "785";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.WonderCure.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"WonderCure"};
		},
		FunctionRemoveEffect
		{
			ApplyTo = "Source";
			Tags = array{ "Plague" };
			MatchAny = true;
		},
		DisplayEffect
		{
			ApplyTo = "Source";
			DisplayGroup = "diseaseimmunity";
			DisplayName = "$DiseaseImmunity.Cured";
			Tags = array{"DiseaseImmunity"};
			Duration = 360;
		},
		FunctionUpdateRelationship
		{
			AffectSource = "2";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
};

"GetDiseaseServiceResultNoPainKiller" = G3ActionTemplate
{
	GUIPresent = false;

	ActionActor = "Character";
	TargetActor = "Building";
	Cooldown = 0.0;
	
	BudgetPost = "Services";
	
	ActionClassName = "SimpleExecutionAction";
	ActionName = "GetDiseaseServiceResultNoPainKiller";
	DisplayName = "$TheBillPlease";
	Description = "$TheBillPleaseDesc";

	SourceScoreFormula = "1";
	TargetScoreFormula = "0";
	
	BaseRewardXP = 0;
	
	CanFail = false;
	CriticalFactor = 1.0;

	ShowCombatText = true;
	OnlyExecute = true;

	SuccessResult = array
	{
		FunctionRemoveEffect
		{
			ApplyTo = "Source";
			Tags = array{ "Leprosy" };
			MatchAny = true;
		},
		DisplayEffect
		{
			ApplyTo = "Source";
			DisplayGroup = "diseaseimmunity";
			DisplayName = "$DiseaseImmunity.Cured";
			Tags = array{"DiseaseImmunity"};
			Duration = 240;
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
};

"GetDiseaseServiceResultPainKiller" = G3ActionTemplate
{
	GUIPresent = false;

	ActionActor = "Character";
	TargetActor = "Building";
	Cooldown = 0.0;
	
	BudgetPost = "Services";
	
	ActionClassName = "SimpleExecutionAction";
	ActionName = "GetDiseaseServiceResultPainKiller";
	DisplayName = "$TheBillPlease";
	Description = "$TheBillPleaseDesc";

	SourceScoreFormula = "1";
	TargetScoreFormula = "0";
	
	BaseRewardXP = 0;
	
	CanFail = false;
	CriticalFactor = 0.85;

	ShowCombatText = true;
	OnlyExecute = true;

	CriticalSuccessResult = array
	{
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.PainKiller.1";
			Giver = "";
			Receiver = "Target";
			Amount = "380";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.PainKiller.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"PainKiller"};
		},
		FunctionRemoveEffect
		{
			ApplyTo = "Source";
			Tags = array{ "Leprosy" };
			MatchAny = true;
		},
		DisplayEffect
		{
			ApplyTo = "Source";
			DisplayGroup = "diseaseimmunity";
			DisplayName = "$DiseaseImmunity.Cured";
			Tags = array{"DiseaseImmunity"};
			Duration = 480;
		},
		FunctionUpdateRelationship
		{
			AffectSource = "3";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
	SuccessResult = array
	{
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.PainKiller.1";
			Giver = "";
			Receiver = "Target";
			Amount = "310";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.PainKiller.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"PainKiller"};
		},
		FunctionRemoveEffect
		{
			ApplyTo = "Source";
			Tags = array{ "Leprosy" };
			MatchAny = true;
		},
		DisplayEffect
		{
			ApplyTo = "Source";
			DisplayGroup = "diseaseimmunity";
			DisplayName = "$DiseaseImmunity.Cured";
			Tags = array{"DiseaseImmunity"};
			Duration = 360;
		},
		FunctionUpdateRelationship
		{
			AffectSource = "2";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
};

"WaitForDiseaseServiceMedicus" = G3ActionTemplate
{
	GUIPresent = false;
	InterruptForSleep = false;
	ActionClassName = "G3Action";
	ActionName = "WaitForDiseaseServiceMedicus";
	ServiceType = "DiseaseService";
	DisplayName = "$action.WaitForDiseaseService.name";
	Description = "$action.WaitForDiseaseService.description";
};

"PoisonService" = G3ActionTemplate
{
	ActionName = "PoisonService";
	ActionClassName = "ServiceAction";
	ServiceType = "PoisonService";
	GUIPresent = false;
	GUIData = array
	{
		ActionGUIData
		{
			IsCharacter = 1;
			BelongsToOwnFamily = 1;
			IsAdult = 1;
		},
		@base/AdultNeutralNPCs
	};

	DisplayName = "$action.TendToPoisonedCustomers";
	Description = "$action.TendToPoisonedCustomersDesc";
	
	CanFail = false;
	InterruptForSleep = false;
	ShowCombatText = false;
	
	OnlyExecute = true;
	EnterBuilding = "TryEnter";	
	
	// List of needs this service can provide. Used as reference when looking for services.
	// The amount is not taken into consideration because it's the GetServiceAction that takes care of it.
	ServiceNeeds = map
	{
		// PoisonService is special because it does not have a corresponding service need. Instead the need for NPCs and AI for this service is generated by being poisoned. Therefore this service is not associated with a service need.
	};
	
	Cooldown = 0.0;
	Duration = 0.0312498; // ~3/4 hour
	
	BudgetPost = "Services";
	
	ActionActor = "Character";
	TargetActor = "AutomationParameters";
	
	SourceScoreFormula = "MedicineMastery";
	
	RequiredBuildings = array
	{
		RequiredBuilding = array { "Apothecary", 1 }
	};
	
	MoralAlignmentShift = 0.06;
	MoralAlignment = MoralAlignment
	{
		Values = array{0.8,1,0.5};
	};
	
	BaseRewardXP = 33;
};

"GetPoisonService" = G3ActionTemplate
{
	GUIPresent = true;
	UICategory = "Urgent";
	OrderIndex = 31;

	ActionName = "GetPoisonService";
	ActionClassName = "GetServiceAction";
	ServiceType = "PoisonService";
	
	// Used to specify the action that is shown while the character is waiting in line
	MainTemplateName = "WaitForPoisonService";
	
	GUIData = array
	{
		ActionGUIData
		{
			IsCharacter = 1;
			BelongsToOwnFamily = 1;
		},
		@base/AllNeutralNPCs
	};
	UsableBy = array{ "$loca.key.anyone" };

	DisplayName = "$action.GetPoisonService";
	Description = "$action.GetPoisonServiceDesc";
	Instruction = "$callToAction.PickAApothecaryPoison";
	
	CanFail = false;
	InterruptForSleep = false;
	ShowCombatText = true;
	OnlyExecute = false;
	EnterBuilding = "TryEnter";
	
	Cooldown = 0.0;
	Duration = 0.5;
	BudgetPost = "Services";
	PriceFormula = "25.0 * countTags.Poison";
	
	// List of needs this action will fulfill. Only used as a reference.
	// FunctionAffectServiceNeeds is still necessary to apply the results
	ServiceNeeds = map
	{
		// PoisonService is special because it does not have a corresponding service need. Instead the need for NPCs and AI for this service is generated by being poisoned. Therefore this service is not associated with a service need.
	};
		
	ActionActor = "Character";
	TargetActor = "Building";
	ShowSelectionPrompt = "UseTargetProfile";
	SelectionPromptCallToAction = "$callToAction.PickAApothecaryPoison";
	SelectionPromptNoTargetMessage = "$selectionPrompt.NoApothecariesPoison";
	
	DesiredProfiles = array
	{
		TargetProfileBuilding
		{
			CityBuilding = -3;
			CanProvideService = 3; // building that offers a matching service
			// Note: the profile intentionally does not check if the workers are off duty. This way the customers will still queue up for the service at night. While they are waiting in the queue, they receive a buff that prevents them from dying.
			CloseToActor = 2;
			CustomerSatisfaction = 2;
			AlreadyServingCustomers = 2;
			FreeWaitingRoomSpace = 3;
			Burning = -3;
			DoesNotHaveAnyTags = array{"ForceClosed"};
			FamilyProfile = TargetProfileFamily
			{
				MyFamily = 2;
				GoodRelationWithMe = 2;
				Alliance = 2;
				Feud = -2;
			};
		};
	};
	
	CriticalFactor = 1.0;
	
	SuccessResult = array
	{
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"GetPoisonServiceResultNoAntidote"};
		},
		FunctionTriggerAction
		{
			Filter = "(Source.hasTag.Poison || Source.hasTag.Poisoned) && Target.hasItems.Antidote.1";
			ApplyTo = "Source";
			ActionTarget = "Target";
			Actions = array{"GetPoisonServiceResultAntidote"};
		}
	};
	FailureResult = array
	{
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		},
		FunctionUpdateRelationship
		{
			AffectSource = "-1";
		}
	};
};

"GetPoisonServiceResultNoAntidote" = G3ActionTemplate
{
	GUIPresent = false;

	ActionActor = "Character";
	TargetActor = "Building";
	Cooldown = 0.0;
	
	BudgetPost = "Services";
	
	ActionClassName = "SimpleExecutionAction";
	ActionName = "GetPoisonServiceResultNoAntidote";
	DisplayName = "$TheBillPlease";
	Description = "$TheBillPleaseDesc";

	SourceScoreFormula = "1";
	TargetScoreFormula = "0";
	
	BaseRewardXP = 0;
	
	CanFail = false;
	CriticalFactor = 1.0;

	ShowCombatText = true;
	OnlyExecute = true;

	SuccessResult = array
	{
		FunctionRemoveEffect
		{
			ApplyTo = "Source";
			Tags = array{ "Poison", "Poisoned" };
			MatchAny = true;
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
};

"GetPoisonServiceResultAntidote" = G3ActionTemplate
{
	GUIPresent = false;

	ActionActor = "Character";
	TargetActor = "Building";
	Cooldown = 0.0;
	
	BudgetPost = "Services";
	
	ActionClassName = "SimpleExecutionAction";
	ActionName = "GetPoisonServiceResultAntidote";
	DisplayName = "$TheBillPlease";
	Description = "$TheBillPleaseDesc";

	SourceScoreFormula = "1";
	TargetScoreFormula = "0";
	
	BaseRewardXP = 0;
	
	CanFail = false;
	CriticalFactor = 0.85;

	ShowCombatText = true;
	OnlyExecute = true;

	CriticalSuccessResult = array
	{
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.Antidote.1";
			Giver = "";
			Receiver = "Target";
			Amount = "490";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.Antidote.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"Antidote"};
		},
		FunctionRemoveEffect
		{
			ApplyTo = "Source";
			Tags = array{ "Poison", "Poisoned" };
			MatchAny = true;
		},
		FunctionUpdateRelationship
		{
			AffectSource = "3";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
	SuccessResult = array
	{
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.Antidote.1";
			Giver = "";
			Receiver = "Target";
			Amount = "410";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.Antidote.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"Antidote"};
		},
		FunctionRemoveEffect
		{
			ApplyTo = "Source";
			Tags = array{ "Poison", "Poisoned" };
			MatchAny = true;
		},
		FunctionUpdateRelationship
		{
			AffectSource = "2";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
};

"WaitForPoisonService" = G3ActionTemplate
{
	GUIPresent = false;
	InterruptForSleep = false;
	ActionClassName = "G3Action";
	ActionName = "WaitForPoisonService";
	ServiceType = "PoisonService";
	DisplayName = "$action.WaitForPoisonService.name";
	Description = "$action.WaitForPoisonService.description";
};


"BodyCareService" = G3ActionTemplate
{
	ActionName = "BodyCareService";
	ActionClassName = "ServiceAction";
	ServiceType = "BodyCareService";
	GUIPresent = false;
	GUIData = array
	{
		ActionGUIData
		{
			IsCharacter = 1;
			BelongsToOwnFamily = 1;
			IsAdult = 1;
		},
		@base/AdultNeutralNPCs
	};

	DisplayName = "$action.AttendToCustomers";
	Description = "$action.AttendToBathCustomersDesc";
	
	CanFail = false;
	InterruptForSleep = false;
	ShowCombatText = false;
	
	OnlyExecute = true;
	EnterBuilding = "TryEnter";
	
	// List of needs this service can provide. Used as reference when looking for services.
	// The amount is not taken into consideration because it's the GetServiceAction that takes care of it.
	ServiceNeeds = map
	{
		"RecreationNeed" = 0.0;
	};
	
	Cooldown = 0.0;
	Duration = 0.0312498; // ~3/4 hour
	//Duration = 0.03211722; // with new animations
	
	BudgetPost = "Services";
	
	ActionActor = "Character";
	TargetActor = "AutomationParameters";
	
	RequiredBuildings = array
	{
		RequiredBuilding = array { "Barber", 1 }
	};
	
	MoralAlignmentShift = 0.05;
	MoralAlignment = MoralAlignment
	{
		Values = array{0.3,0.5,0};
	};
	
	BaseRewardXP = 33;
};

"GetBodyCareService" = G3ActionTemplate
{
	GUIPresent = true;
	UICategory = "Urgent";
	OrderIndex = 25;

	ActionName = "GetBodyCareService";
	ActionClassName = "GetServiceAction";
	ServiceType = "BodyCareService";
	
	// Used to specify the action that is shown while the character is waiting in line
	MainTemplateName = "WaitForBodyCareService";
	
	GUIData = array
	{
		ActionGUIData
		{
			IsCharacter = 1;
			BelongsToOwnFamily = 1;
			IsAdult = 1;
		},
		ActionGUIData
		{
			HasFamily = 0;
			IsAdult = 1;
			IsUnlockedAction = -1;
			IsFamilyMember = -1;
			BelongsToOwnFamily = 1;
			DoesNotHaveTag = "NoService";
		}
	};
	UsableBy = array{ "$characters.Age.Adult" };

	DisplayName = "$action.GetBathService";
	Description = "$action.GetBathServiceDesc";
	Instruction = "$callToAction.BarberBusinessBodyCare";
	
	CanFail = false;
	InterruptForSleep = false;
	ShowCombatText = true;
	OnlyExecute = false;
	EnterBuilding = "TryEnter";
	
	Cooldown = 0.0;
	Duration = 0.1;

	PriceFormula = "25";
	BudgetPost = "Services";
	BaseRewardXP = 12;
	
	// List of needs this action will fulfill. Only used as a reference.
	// FunctionAffectServiceNeeds is still necessary to apply the results
	ServiceNeeds = map
	{
		"RecreationNeed" = 1.0;
	};
	
	ActionActor = "Character";
	TargetActor = "Building";
	ShowSelectionPrompt = "UseTargetProfile";
	SelectionPromptCallToAction = "$callToAction.BarberBusinessBodyCare";
	SelectionPromptNoTargetMessage = "$selectionPrompt.NoBarberFoundBodyCare";
	
	DesiredProfiles = array
	{
		TargetProfileBuilding
		{
			CityBuilding = -3;
			CanProvideService = 3; // building that offers a matching service
			HasServiceEmployeesOnActiveShift = 3; // Employees are not sleeping
			CloseToActor = 2;
			CustomerSatisfaction = 2;
			AlreadyServingCustomers = 2;
			FreeWaitingRoomSpace = 3;
			Burning = -3;
			DoesNotHaveAnyTags = array{"ForceClosed"};
			FamilyProfile = TargetProfileFamily
			{
				MyFamily = 2;
				GoodRelationWithMe = 2;
				Alliance = 2;
				Feud = -2;
			};
		};
	};
	
	CriticalFactor = 1.0;
	
	SuccessResult = array
	{
		FunctionAffectServiceNeeds
		{
			ApplyTo = "Self";
			ServiceNeeds = map
			{
				"RecreationNeed" = -1.0;
			};
		},
		FunctionRemoveEffect
		{
			MatchAny = true;
			Tags = array{"Washed"};
			ApplyTo = "Self";
		},
		DisplayEffect
		{
			Tags = array{"Washed"};
			ApplyTo = "Self";
			Duration = 360;
			DisplayGroup = "perfume";
			DisplayName = "$statusEffect.Washed";
		},
		ModifierEffect
		{
			Tags = array{"Washed"};
			ApplyTo = "Self";
			ActorValue = "Charisma";
			Mod = 1.0;
			Recover = true;
			Duration = 360;
		},
		ModifierEffect
		{
			Tags = array{"Washed"};
			ApplyTo = "Self";
			ActorValue = "ReputationBonus";
			Mod = 0.1;
			Duration = 360.0;
			Recover = true;
		};
		FunctionTriggerAction
		{
			Filter = "hasTag.LoveDebuff";
			ApplyTo = "Self";
			Actions = array{"RomanceHealDebuff"};
		},
		FunctionRemoveEffect
		{
			MatchAny = true;
			Tags = array{"Fleas","LoveDebuff"};
			ApplyTo = "Self";
		},
		FunctionTriggerAction
		{
			Filter = "!Target.hasItems.Soap.1";
			ApplyTo = "Source";
			Actions = array{"GetBodyCareServiceExit"};
		},
		FunctionTriggerAction
		{
			Filter = "Target.hasItems.Soap.1";
			ApplyTo = "Source";
			ActionTarget = "Target";
			Actions = array{"GetBodyCareServiceResult"};
		},
	};
	FailureResult = array
	{
		FunctionTriggerAction
		{
			Filter = "HasServiceStarted";
			ApplyTo = "Source";
			Actions = array{"GetBodyCareServiceExit"};
		},
		FunctionTriggerAction
		{
			Filter = "!HasServiceStarted";
			ApplyTo = "Source";
			Actions = array{"Exit"};
		},
		FunctionUpdateRelationship
		{
			AffectSource = "-1";
		}
	};
};

"GetBodyCareServiceResult" = G3ActionTemplate
{
	GUIPresent = false;
	CanFail = false;
	
	ActionName = "GetBodyCareServiceResult";
	DisplayName = "$TheBillPlease";
	Description = "$TheBillPleaseDesc";
	BudgetPost = "Services";

	ActionActor = "Character";
	TargetActor = "Building";
	ActionClassName = "SimpleExecutionAction";

	SourceScoreFormula = "1";
	TargetScoreFormula = "0";
	
	ShowCombatText = true;

	CanFail = false;
	CriticalFactor = 0.85;

	Duration = 0.0015;
	
	TargetSnapPoint = TargetSnapPoint
	{
		Required = true;
		ShouldReserve = false;
		ShouldOccupy = false;
		
		Profiles = array
		{
			TargetProfileSnapPoint{ Context = "GetBodyCareServiceResult"; Inside = -3; IsFree = 3; },
		};
	};
	
	CriticalSuccessResult = array
	{
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.Soap.1";
			Giver = "";
			Receiver = "Target";
			Amount = "90";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.Soap.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"Soap"};
		},
		FunctionUpdateRelationship
		{
			AffectSource = "1";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"GetBodyCareServiceOutHere"};
		}
	};
	SuccessResult = array
	{
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.Soap.1";
			Giver = "";
			Receiver = "Target";
			Amount = "65";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.Soap.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"Soap"};
		},
		FunctionUpdateRelationship
		{
			AffectSource = "1";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"GetBodyCareServiceOutHere"};
		}
	};
};

"GetBodyCareServiceExit" = G3ActionTemplate
{
	GUIPresent = false;
	CanFail = false;
	
	ActionName = "GetBodyCareServiceExit";
	DisplayName = "$TheBillPlease";
	Description = "$TheBillPleaseDesc";
	BudgetPost = "Services";

	ActionActor = "Character";
	TargetActor = "Building";
	ActionClassName = "SimpleExecutionAction";

	SourceScoreFormula = "1";
	TargetScoreFormula = "0";
	
	ShowCombatText = true;

	CanFail = false;

	Duration = 0.0015;
	
	TargetSnapPoint = TargetSnapPoint
	{
		Required = true;
		ShouldReserve = false;
		ShouldOccupy = false;
		
		Profiles = array
		{
			TargetProfileSnapPoint{ Context = "GetBodyCareServiceExit"; Inside = -3; IsFree = 3; },
		};
	};
	
	SuccessResult = array
	{
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"GetBodyCareServiceOutHere"};
		}
	};
};
"GetBodyCareServiceOutHere" = G3ActionTemplate
{
	GUIPresent = false;
	CanFail = false;
	
	ActionName = "GetBodyCareServiceOutHere";
	DisplayName = "$TheBillPlease";
	Description = "$TheBillPleaseDesc";
	BudgetPost = "Services";

	ActionActor = "Character";
	TargetActor = "Building";
	ActionClassName = "SimpleExecutionAction";

	SourceScoreFormula = "1";
	TargetScoreFormula = "0";
	
	ShowCombatText = true;

	CanFail = false;

	Duration = 0.0;
	
	TargetSnapPoint = TargetSnapPoint
	{
		Required = true;
		ShouldReserve = false;
		ShouldOccupy = false;
		
		Profiles = array
		{
			TargetProfileSnapPoint{ Context = "GetBodyCareServiceOutHere"; Inside = -3; },
		};
	};
	
	SuccessResult = array
	{
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"ForcedExit"};
		}
	};
};

"WaitForBodyCareService" = G3ActionTemplate
{
	GUIPresent = false;
	ActionClassName = "G3Action";
	ActionName = "WaitForBodyCareService";
	ServiceType = "BodyCareService";
	DisplayName = "$action.WaitForBathService.name";
	Description = "$action.WaitForBathService.description";
};

"GastronomyService" = G3ActionTemplate
{
	ActionName = "GastronomyService";
	ActionClassName = "ServiceAction";
	ServiceType = "GastronomyService";
	GUIPresent = false;
	GUIData = array
	{
		ActionGUIData
		{
			IsCharacter = 1;
			BelongsToOwnFamily = 1;
			IsAdult = 1;
		},
		@base/AdultNeutralNPCs
	};

	DisplayName = "$action.AttendToCustomers";
	Description = "$action.AttendToGastronomyCustomersDesc";
	
	CanFail = false;
	InterruptForSleep = false;
	ShowCombatText = false;
	
	OnlyExecute = true;
	EnterBuilding = "TryEnter";
	
	// List of needs this service can provide. Used as reference when looking for services.
	// The amount is not taken into consideration because it's the GetServiceAction that takes care of it.
	ServiceNeeds = map
	{
		"RecreationNeed" = 0.0;
	};
	
	Cooldown = 0.0;
	Duration = 0.0312498; // ~3/4 hour
	
	BudgetPost = "Services";
	
	ActionActor = "Character";
	TargetActor = "AutomationParameters";
	
	RequiredBuildings = array
	{
		RequiredBuilding = array { "Inn", 1 }
	};
	
	MoralAlignmentShift = 0.05;
	MoralAlignment = MoralAlignment
	{
		Values = array{0,-0.1,0};
	};
	
	BaseRewardXP = 33;
};

"GetGastronomyService" = G3ActionTemplate
{
	GUIPresent = true;
	UICategory = "Urgent";
	OrderIndex = 12;

	ActionName = "GetGastronomyService";
	ActionClassName = "GetServiceAction";
	ServiceType = "GastronomyService";
	
	// Used to specify the action that is shown while the character is waiting in line
	MainTemplateName = "WaitForGastronomyService";
	
	GUIData = array
	{
		ActionGUIData
		{
			IsCharacter = 1;
			BelongsToOwnFamily = 1;
			IsAdult = 1;
		},
		ActionGUIData
		{
			HasFamily = 0;
			IsAdult = 1;
			IsUnlockedAction = -1;
			IsFamilyMember = -1;
			BelongsToOwnFamily = 1;
			DoesNotHaveTag = "NoService";
		}
	};
	UsableBy = array{ "$characters.Age.Adult" };

	DisplayName = "$action.GetGastronomyService";
	Description = "$action.GetGastronomyServiceDesc";
	Instruction = "$callToAction.BuildingPublicHouseGastronomy";
	
	CanFail = false;
	InterruptForSleep = false;
	ShowCombatText = false;
	OnlyExecute = false;
	EnterBuilding = "TryEnter";
	
	Cooldown = 0.0;
	Duration = 0.1;
	PriceFormula = "25";
	BudgetPost = "Services";
	BaseRewardXP = 12;
	
	// List of needs this action will fulfill. Only used as a reference.
	// FunctionAffectServiceNeeds is still necessary to apply the results
	ServiceNeeds = map
	{
		"RecreationNeed" = 1.0;
	};
	
	ActionActor = "Character";
	TargetActor = "Building";
	ShowSelectionPrompt = "UseTargetProfile";
	SelectionPromptCallToAction = "$callToAction.BuildingPublicHouseGastronomy";
	SelectionPromptNoTargetMessage = "$selectionPrompt.NoBuildingPublicHouseGastronomy";
	
	DesiredProfiles = array
	{
		TargetProfileBuilding
		{
			CityBuilding = -3;
			CanProvideService = 3; // building that offers a matching service
			HasServiceEmployeesOnActiveShift = 3; // Employees are not sleeping
			CloseToActor = 2;
			CustomerSatisfaction = 2;
			AlreadyServingCustomers = 2;
			FreeWaitingRoomSpace = 3;
			Burning = -3;
			DoesNotHaveAnyTags = array{"ForceClosed"};
			FamilyProfile = TargetProfileFamily
			{
				MyFamily = 2;
				GoodRelationWithMe = 2;
				Alliance = 2;
				Feud = -2;
			};
		};
	};
	
	CriticalFactor = 1.0;
	
	SuccessResult = array
	{
		FunctionAffectServiceNeeds
		{
			ApplyTo = "Self";
			ServiceNeeds = map
			{
				"RecreationNeed" = -1.0;
			};
		},
		FunctionTriggerAction
		{
			Filter = "Target.hasItems.SmallBeer.1";
			ApplyTo = "Source";
			ActionTarget = "Target";
			Actions = array{"GetGastronomyServiceResultSmallBeer"};
		},
		FunctionTriggerAction
		{
			Filter = "Target.hasItems.Sausage.1";
			ApplyTo = "Source";
			ActionTarget = "Target";
			Actions = array{"GetGastronomyServiceResultSausage"};
		},
		FunctionTriggerAction
		{
			Filter = "Target.hasItems.SmallBeer.1 && Target.hasItems.Sausage.1";
			ApplyTo = "Source";
			ActionTarget = "Target";
			Actions = array{"GetGastronomyServiceResultSmallBeer", "GetGastronomyServiceResultSausage"};
		},
		FunctionTriggerAction
		{
			Filter = "Target.hasItems.WheatBeer.1";
			ApplyTo = "Source";
			ActionTarget = "Target";
			Actions = array{"GetGastronomyServiceResultWheatBeer"};
		},
		FunctionTriggerAction
		{
			Filter = "Target.hasItems.RoastBeef.1";
			ApplyTo = "Source";
			ActionTarget = "Target";
			Actions = array{"GetGastronomyServiceResultRoastBeef"};
		},
		FunctionTriggerAction
		{
			Filter = "Target.hasItems.WheatBeer.1 && Target.hasItems.RoastBeef.1";
			ApplyTo = "Source";
			ActionTarget = "Target";
			Actions = array{"GetGastronomyServiceResultWheatBeer", "GetGastronomyServiceResultRoastBeef"};
		},
		FunctionTriggerAction
		{
			Filter = "hasTag.LoveDebuff";
			ApplyTo = "Self";
			Actions = array{"RomanceHealDebuff"};
		},
		FunctionRemoveEffect
		{
			ApplyTo = "Self";
			MatchAny = true;
			Tags = array {"LoveDebuff"};
		},
		FunctionTriggerAction
		{
			Filter = "!Target.hasItems.SmallBeer.1 && !Target.hasItems.Sausage.1 && !Target.hasItems.WheatBeer.1 && !Target.hasItems.RoastBeef.1";
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
	FailureResult = array
	{
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		},
		FunctionUpdateRelationship
		{
			AffectSource = "-1";
		}
	};
};

"WaitForGastronomyService" = G3ActionTemplate
{
	GUIPresent = false;
	ActionClassName = "G3Action";
	ActionName = "WaitForGastronomyService";
	ServiceType = "GastronomyService";
	DisplayName = "$action.WaitForGastronomyService.name";
	Description = "$action.WaitForGastronomyService.description";
};

"GetGastronomyServiceResultSmallBeer" = G3ActionTemplate
{
	GUIPresent = false;

	ActionActor = "Character";
	TargetActor = "Building";
	Cooldown = 0.0;
	
	BudgetPost = "Services";
	
	ActionClassName = "SimpleExecutionAction";
	ActionName = "GetGastronomyServiceResultSmallBeer";
	DisplayName = "$TheBillPlease";
	Description = "$TheBillPleaseDesc";

	SourceScoreFormula = "1";
	TargetScoreFormula = "0";
	
	BaseRewardXP = 0;
	
	CanFail = false;
	CriticalFactor = 0.85;

	ShowCombatText = true;
	OnlyExecute = true;
	EnterBuilding = "TryEnter";

	CriticalSuccessResult = array
	{
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.SmallBeer.1";
			Giver = "";
			Receiver = "Target";
			Amount = "150";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.SmallBeer.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"SmallBeer"};
		},
		FunctionUpdateRelationship
		{
			AffectSource = "1";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
	SuccessResult = array
	{
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.SmallBeer.1";
			Giver = "";
			Receiver = "Target";
			Amount = "115";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.SmallBeer.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"SmallBeer"};
		},
		FunctionUpdateRelationship
		{
			AffectSource = "1";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
};

"GetGastronomyServiceResultWheatBeer" = G3ActionTemplate
{
	GUIPresent = false;

	ActionActor = "Character";
	TargetActor = "Building";
	Cooldown = 0.0;
	
	BudgetPost = "Services";
	
	ActionClassName = "SimpleExecutionAction";
	ActionName = "GetGastronomyServiceResultWheatBeer";
	DisplayName = "$TheBillPlease";
	Description = "$TheBillPleaseDesc";

	SourceScoreFormula = "1";
	TargetScoreFormula = "0";
	
	BaseRewardXP = 0;
	
	CanFail = false;
	CriticalFactor = 0.85;

	ShowCombatText = true;
	OnlyExecute = true;
	EnterBuilding = "TryEnter";

	CriticalSuccessResult = array
	{
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.WheatBeer.1";
			Giver = "";
			Receiver = "Target";
			Amount = "520";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.WheatBeer.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"WheatBeer"};
		},
		FunctionUpdateRelationship
		{
			AffectSource = "1";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
	SuccessResult = array
	{
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.WheatBeer.1";
			Giver = "";
			Receiver = "Target";
			Amount = "430";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.WheatBeer.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"WheatBeer"};
		},
		FunctionUpdateRelationship
		{
			AffectSource = "1";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
};

"GetGastronomyServiceResultSausage" = G3ActionTemplate
{
	GUIPresent = false;

	ActionActor = "Character";
	TargetActor = "Building";
	Cooldown = 0.0;
	
	BudgetPost = "Services";
	
	ActionClassName = "SimpleExecutionAction";
	ActionName = "GetGastronomyServiceResultSausage";
	DisplayName = "$TheBillPlease";
	Description = "$TheBillPleaseDesc";

	SourceScoreFormula = "1";
	TargetScoreFormula = "0";
	
	BaseRewardXP = 0;
	
	CanFail = false;
	CriticalFactor = 0.85;

	ShowCombatText = true;
	OnlyExecute = true;
	EnterBuilding = "TryEnter";

	CriticalSuccessResult = array
	{
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.Sausage.1";
			Giver = "";
			Receiver = "Target";
			Amount = "500";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.Sausage.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"Sausage"};
		},
		FunctionUpdateRelationship
		{
			AffectSource = "1";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
	SuccessResult = array
	{
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.Sausage.1";
			Giver = "";
			Receiver = "Target";
			Amount = "420";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.Sausage.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"Sausage"};
		},
		FunctionUpdateRelationship
		{
			AffectSource = "1";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
};

"GetGastronomyServiceResultRoastBeef" = G3ActionTemplate
{
	GUIPresent = false;

	ActionActor = "Character";
	TargetActor = "Building";
	Cooldown = 0.0;
	
	BudgetPost = "Services";
	
	ActionClassName = "SimpleExecutionAction";
	ActionName = "GetGastronomyServiceResultRoastBeef";
	DisplayName = "$TheBillPlease";
	Description = "$TheBillPleaseDesc";

	SourceScoreFormula = "1";
	TargetScoreFormula = "0";
	
	BaseRewardXP = 0;
	
	CanFail = false;
	CriticalFactor = 0.85;

	ShowCombatText = true;
	OnlyExecute = true;
	EnterBuilding = "TryEnter";

	CriticalSuccessResult = array
	{
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.RoastBeef.1";
			Giver = "";
			Receiver = "Target";
			Amount = "560";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.RoastBeef.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"RoastBeef"};
		},
		FunctionUpdateRelationship
		{
			AffectSource = "1";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
	SuccessResult = array
	{
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.RoastBeef.1";
			Giver = "";
			Receiver = "Target";
			Amount = "465";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.RoastBeef.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"RoastBeef"};
		},
		FunctionUpdateRelationship
		{
			AffectSource = "1";
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
};

// ***************
"SpeakeasyService" = G3ActionTemplate
{
	ActionName = "SpeakeasyService";
	ActionClassName = "ServiceAction";
	ServiceType = "SpeakeasyService";
	GUIPresent = false;
	GUIData = array
	{
		ActionGUIData
		{
			IsCharacter = 1;
			BelongsToOwnFamily = 1;
			IsAdult = 1;
			IsAtEmployer = 1;
		},
		@base/AdultNeutralNPCs
	};

	DisplayName = "$action.AttendToCustomers";
	Description = "$action.AttendToSpeakeasyCustomersDesc";
	
	CanFail = false;
	InterruptForSleep = false;
	ShowCombatText = false;
	
	OnlyExecute = true;
	EnterBuilding = "TryEnter";
	
	// List of needs this service can provide. Used as reference when looking for services.
	// The amount is not taken into consideration because it's the GetServiceAction that takes care of it.
	ServiceNeeds = map
	{
		"RecreationNeed" = 0.0;
	};
	
	Cooldown = 0.0;
	Duration = 0.021; // ~1/2 hour
	
	BudgetPost = "Services";
	
	ActionActor = "Character";
	TargetActor = "AutomationParameters";
	
	RequiredBuildings = array
	{
		RequiredBuilding = array { "Smuggler", 1 }
	};
	
	MoralAlignmentShift = 0.05;
	MoralAlignment = MoralAlignment
	{
		Values = array{0,0.3,0.5};
	};
	
	BaseRewardXP = 33;

	SourceScoreFormula = "Perception * 0.5 + Stealth * 0.5 + Motivation";
	TargetScoreFormula = "3";
	
	CanFail = true;
	CriticalFactor = 1.0;
	
	SuccessResult = array
	{
		FunctionPickRandom
		{
			ResultObjectIds =  array{"ApplySmugglerBuff1", "ApplySmugglerBuff2", "ApplySmugglerBuff3"};
		},
	};
	FailureResult = array
	{
	};
};

"GetSpeakeasyService" = G3ActionTemplate
{
	GUIPresent = true;
	UICategory = "Urgent";
	OrderIndex = 12;

	ActionName = "GetSpeakeasyService";
	ActionClassName = "GetServiceAction";
	ServiceType = "SpeakeasyService";
	
	// Used to specify the action that is shown while the character is waiting in line
	MainTemplateName = "WaitForSpeakeasyService";
	
	GUIData = array
	{
		ActionGUIData
		{
			IsCharacter = 1;
			BelongsToOwnFamily = 1;
			IsAdult = 1;
		},
		ActionGUIData
		{
			HasFamily = 0;
			IsAdult = 1;
			IsUnlockedAction = -1;
			IsFamilyMember = -1;
			BelongsToOwnFamily = 1;
			//DoesNotHaveTag = "NoService";
			DoesHaveTag = "LuredToSmuggler";
		}
	};
	UsableBy = array{ "$characters.Age.Adult" };

	DisplayName = "$action.GetSpeakeasyService";
	Description = "$action.GetSpeakeasyServiceDesc";
	Instruction = "$callToAction.BuildingSmugglerSpeakeasyService";
	
	CanFail = false;
	InterruptForSleep = false;
	ShowCombatText = false;
	OnlyExecute = false;
	EnterBuilding = "TryEnter";
	
	Cooldown = 0.0;
	Duration = 0.1;
	PriceFormula = "25";
	BudgetPost = "Services";
	BaseRewardXP = 12;
	
	// List of needs this action will fulfill. Only used as a reference.
	// FunctionAffectServiceNeeds is still necessary to apply the results
	ServiceNeeds = map
	{
		"RecreationNeed" = 1.0;
	};
	
	ActionActor = "Character";
	TargetActor = "Building";
	ShowSelectionPrompt = "UseTargetProfile";
	SelectionPromptCallToAction = "$callToAction.BuildingSmugglerSpeakeasyService";
	SelectionPromptNoTargetMessage = "$selectionPrompt.NoBuildingSmugglerSpeakeasy";
	
	DesiredProfiles = array
	{
		TargetProfileBuilding
		{
			CityBuilding = -3;
			CanProvideService = 3; // building that offers a matching service
			HasServiceEmployeesOnActiveShift = 3; // Employees are not sleeping
			CloseToActor = 2;
			CustomerSatisfaction = 2;
			AlreadyServingCustomers = 2;
			FreeWaitingRoomSpace = 3;
			Burning = -3;
			DoesNotHaveAnyTags = array{"ForceClosed"};
			FamilyProfile = TargetProfileFamily
			{
				MyFamily = 2;
				GoodRelationWithMe = 2;
				Alliance = 2;
				Feud = -2;
			};
		};
	};
	
	MoralAlignmentShift = 0.05;
	MoralAlignment = MoralAlignment
	{
		Values = array{-0.6,-0.3,0};
	};
	
	CriticalFactor = 1.0;
	
	SuccessResult = array
	{
		FunctionAffectServiceNeeds
		{
			ApplyTo = "Self";
			ServiceNeeds = map
			{
				"RecreationNeed" = -1.0;
			};
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"GetSpeakeasyServiceResult"};
		}
	};
	FailureResult = array
	{
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		},
	};
};

"WaitForSpeakeasyService" = G3ActionTemplate
{
	GUIPresent = false;
	ActionClassName = "G3Action";
	ActionName = "WaitForSpeakeasyService";
	ServiceType = "SpeakeasyService";
	DisplayName = "$action.WaitForSpeakeasyService.name";
	Description = "$action.WaitForSpeakeasyService.description";
};

"GetSpeakeasyServiceResult" = G3ActionTemplate
{
	GUIPresent = false;

	ActionActor = "Character";
	TargetActor = "Building";
	Cooldown = 0.0;
	
	BudgetPost = "Services";
	
	ActionClassName = "SimpleExecutionAction";
	ActionName = "GetSpeakeasyServiceResult";
	DisplayName = "$action.GetSpeakeasyService";
	Description = "$action.GetSpeakeasyServiceDesc";

	SourceScoreFormula = "1";
	TargetScoreFormula = "0";
	
	BaseRewardXP = 0;
	
	CanFail = false;
	CriticalFactor = 0.85;

	ShowCombatText = true;
	OnlyExecute = true;

	CriticalSuccessResult = array
	{
		VisualEffect
		{
			ApplyTo = "Self";
			VisualName = "Inebriate";
			Duration = 5.0;
		},
		DisplayEffect
		{
			Tags = array{"Drunk", "Drunken"};
			ApplyTo = "Self";
			DisplayGroup = "drunk";
			DisplayName = "$action.GetSpeakeasyService";
			Duration = 240.0;
		},
		ModifierEffect
		{
			Tags = array{"Drunk","Drunken"};
			ApplyTo = "Self";
			ActorValue = "Charisma";
			Mod = 1;
			Duration = 240.0;
			Recover = true;
		},
		ModifierEffect
		{
			Tags = array{"Drunk","Drunken"};
			ApplyTo = "Self";
			ActorValue = "Intelligence";
			Mod = -1;
			Duration = 240.0;
			Recover = true;
		},
		DisplayEffect
		{
			Tags = array{"Drunk", "Drunken"};
			ApplyTo = "Self";
			DisplayGroup = "drunk";
			DisplayName = "$action.GetSpeakeasyService";
			Duration = 240.0;
		},
		ModifierEffect
		{
			Tags = array{"Slow","Drunken"};
			ApplyTo = "Self";
			ActorValue = "MovementSpeedMult";
			Mod = -0.25;
			Duration = 240.0;
			Recover = true;
		},
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.Rum.1";
			Giver = "";
			Receiver = "Target";
			Amount = "120";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.Rum.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"Rum"};
		},
		FunctionUpdateRelationship
		{
			AffectSource = "1";
		},
		FunctionTriggerAction
		{
			Filter = "hasTag.LoveDebuff";
			ApplyTo = "Self";
			Actions = array{"RomanceHealDebuff"};
		},
		FunctionRemoveEffect
		{
			ApplyTo = "Self";
			MatchAny = true;
			Tags = array {"LoveDebuff"};
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		}
	};
	SuccessResult = array
	{
		FunctionTransferMoney
		{
			Filter = "Target.hasItems.Rum.1";
			Giver = "";
			Receiver = "Target";
			Amount = "85";
		},
		FunctionTransferItems
		{
			Filter = "Target.hasItems.Rum.1";
			Giver = "Target";
			Receiver = "";
			MinAmount = 1;
			MaxAmount = 1;
			SpecificItems = array{"Rum"};
		},
		FunctionTriggerAction
		{
			ApplyTo = "Source";
			Actions = array{"Exit"};
		},
		FunctionTriggerAction
		{
			Filter = "hasTag.LoveDebuff";
			ApplyTo = "Self";
			Actions = array{"RomanceHealDebuff"};
		},
		FunctionRemoveEffect
		{
			ApplyTo = "Self";
			MatchAny = true;
			Tags = array {"LoveDebuff"};
		}
	};
};
// ***************

"ApplySmugglerBuff1" = G3ActionTemplate
{
	GUIPresent = false;
	CanFail = false;
	
	ActionName = "ApplySmugglerBuff1";
	DisplayName = "$NPC.Thinking";
	Description = "$NPC.ThinkingDesc";

	ActionActor = "Character";
	ActionClassName = "SimpleExecutionAction";
	
	ShowCombatText = true;

	CanFail = false;
	CriticalFactor = 1.0;
	
	SuccessResult =  array
	{
		FunctionRemoveEffect
		{
			ApplyTo = "Source";
			MatchAny = true;
			Tags = array {"SmugglerBuff1"};
		},
		DisplayEffect
		{
			Tags = array{"SmugglerBuff1"};
			ApplyTo = "Source";
			DisplayGroup = "buffed";
			DisplayName = "$effect.SmugglerBuff1";
			Duration = 540.0;
		}
	};
};

"ApplySmugglerBuff2" = G3ActionTemplate
{
	GUIPresent = false;
	CanFail = false;
	
	ActionName = "ApplySmugglerBuff2";
	DisplayName = "$NPC.Thinking";
	Description = "$NPC.ThinkingDesc";

	ActionActor = "Character";
	ActionClassName = "SimpleExecutionAction";
	
	ShowCombatText = true;

	CanFail = false;
	CriticalFactor = 1.0;
	
	SuccessResult =  array
	{
		FunctionRemoveEffect
		{
			ApplyTo = "Source";
			MatchAny = true;
			Tags = array {"SmugglerBuff2"};
		},
		DisplayEffect
		{
			Tags = array{"SmugglerBuff2"};
			ApplyTo = "Source";
			DisplayGroup = "buffed";
			DisplayName = "$effect.SmugglerBuff2";
			Duration = 540.0;
		}
	};
};

"ApplySmugglerBuff3" = G3ActionTemplate
{
	GUIPresent = false;
	CanFail = false;
	
	ActionName = "ApplySmugglerBuff3";
	DisplayName = "$NPC.Thinking";
	Description = "$NPC.ThinkingDesc";

	ActionActor = "Character";
	ActionClassName = "SimpleExecutionAction";
	
	ShowCombatText = true;

	CanFail = false;
	CriticalFactor = 1.0;
	
	SuccessResult =  array
	{
		FunctionRemoveEffect
		{
			ApplyTo = "Source";
			MatchAny = true;
			Tags = array {"SmugglerBuff3"};
		},
		DisplayEffect
		{
			Tags = array{"SmugglerBuff3"};
			ApplyTo = "Source";
			DisplayGroup = "buffed";
			DisplayName = "$effect.SmugglerBuff3";
			Duration = 540.0;
		}
	};
};
